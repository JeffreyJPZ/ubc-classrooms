name: cd

on:
  push:
    branches:
      - main
    paths-ignore:
      - .github/**
  pull_request:
    branches:
      - main
    types:
      - closed
    paths-ignore:
      - .github/**

jobs:
  create-tags:
    name: Generate tag names using datetime and commit ids
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    
    steps:
      - name: Get datetime
        id: now
        run: echo "now=$(date + '%Y-%m-%dT%H%M%S')" >> $GITHUB_OUTPUT
      
      - name: Generate tag name
        id: tag
        run: echo "tag=${{ steps.now.outputs.now }}"

  build-and-push:
    name: Build Docker images and push to registry
    needs: create-tags
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build images
        run: docker compose -f compose.prod.yml build

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull remaining images
        run: docker compose -f compose.prod.yml pull db certbot

      - name: Tag and push images
        run: |
          docker tag postgres:16.3 ubcclassrooms/db:${{ needs.create-tags.outputs.tag }}
          docker tag postgres:16.3 ubcclassrooms/db:latest
          docker push ubcclassrooms/db --all-tags
          docker tag ubc-classrooms-web ubcclassrooms/web:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-web ubcclassrooms/web:latest
          docker push ubcclassrooms/web --all-tags
          docker tag ubc-classrooms-nginx ubcclassrooms/nginx:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-nginx ubcclassrooms/nginx:latest
          docker push ubcclassrooms/nginx --all-tags
          docker tag certbot/certbot ubcclassrooms/certbot:${{ needs.create-tags.outputs.tag }}
          docker tag certbot/certbot ubcclassrooms/certbot:latest
          docker push ubcclassrooms/certbot --all-tags
          docker tag ubc-classrooms-scrape-classrooms ubcclassrooms/scrape-classrooms:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-scrape-classrooms ubcclassrooms/scrape-classrooms:latest
          docker push ubcclassrooms/scrape-classrooms --all-tags
          docker tag ubc-classrooms-compute-timeslots compute-timeslots ubcclassrooms/compute-timeslots:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-compute-timeslots ubcclassrooms/compute-timeslots:latest
          docker push ubcclassrooms/compute-timeslots --all-tags
          docker tag ubc-classrooms-create-models ubcclassrooms/create-models:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-create-models ubcclassrooms/create-models:latest
          docker push ubcclassrooms/create-models --all-tags
          docker tag ubc-classrooms-delete-expired-timeslots ubcclassrooms/delete-expired-timeslots:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-delete-expired-timeslots ubcclassrooms/delete-expired-timeslots:latest
          docker push ubcclassrooms/delete-expired-timeslots --all-tags
          docker tag ubc-classrooms-api-tests ubcclassrooms/api-tests:${{ needs.create-tags.outputs.tag }}
          docker tag ubc-classrooms-api-tests ubcclassrooms/api-tests:latest
          docker push ubcclassrooms/api-tests --all-tags

  deploy:
    name: Deploy to production server
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: production
    env:
      SQL_ENGINE: ${{ secrets.SQL_ENGINE }}
      SQL_DB: ${{ secrets.SQL_DB_PROD }}
      SQL_USER: ${{ secrets.SQL_USER }}
      SQL_PASSWORD: ${{ secrets.SQL_PASSWORD }}
      SQL_HOST: ${{ secrets.SQL_HOST }}
      SQL_PORT: ${{ secrets.SQL_PORT }}
      DB: ${{ secrets.DB }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB_PROD }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      DEBUG: ${{ vars.DEBUG }}
      DJANGO_ALLOWED_HOSTS: ${{ vars.DJANGO_ALLOWED_HOSTS }}
      DJANGO_PROD_SECRET_KEY: ${{ secrets.DJANGO_PROD_SECRET_KEY}}
      CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
      REGISTRY: ${{ vars.REGISTRY }}
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}

    steps:
      - name: Deploy to production server via SSH action
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          envs: DOCKERHUB_USERNAME,DOCKERHUB_TOKEN,SQL_ENGINE,SQL_DB,SQL_USER,SQL_PASSWORD,SQL_HOST,SQL_PORT,DB,POSTGRES_DB,POSTGRES_USER,POSTGRES_PASSWORD,DEBUG,DJANGO_ALLOWED_HOSTS,DJANGO_PROD_SECRET_KEY,CERTBOT_EMAIL,REGISTRY
          script: |
            # Change directory to project root
            cd /
            cd srv/ubc-classrooms
            # Pull from main branch
            sudo git pull origin main
            # Create production env file if it doesnt exist already
            if [ ! -e "prod.env" ]
            then
              sudo touch prod.env
              sudo echo SQL_ENGINE=$SQL_ENGINE >> prod.env
              sudo echo SQL_DB=$SQL_DB >> prod.env
              sudo echo SQL_USER=$SQL_USER >> prod.env
              sudo echo SQL_PASSWORD=$SQL_PASSWORD >> prod.env
              sudo echo SQL_HOST=SQL_HOST >> prod.env
              sudo echo SQL_PORT=$SQL_PORT >> prod.env
              sudo echo DB=$DB >> prod.env
              sudo echo POSTGRES_DB=$POSTGRES_DB >> prod.env
              sudo echo POSTGRES_USER=$POSTGRES_USER >> prod.env
              sudo echo POSTGRES_PASSWORD=$POSTGRES_PASSWORD >> prod.env
              sudo echo DEBUG=$DEBUG >> prod.env
              sudo echo DJANGO_ALLOWED_HOSTS=$DJANGO_ALLOWED_HOSTS >> prod.env
              sudo echo DJANGO_PROD_SECRET_KEY=$DJANGO_PROD_SECRET_KEY >> prod.env
              sudo echo CERTBOT_EMAIL=$CERTBOT_EMAIL >> prod.env
            fi
            # Login to registry
            sudo docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_TOKEN
            # Pull latest images
            sudo docker compose -f compose.srv.yml pull
            # Recreate and restart services
            sudo docker compose -f compose.srv.yml up db web nginx -d --wait --force-recreate
